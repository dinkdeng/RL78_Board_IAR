#include "adc.h"

uint8_t convertOver = 0;

DDIL_ERROR_CODE Adc_Init(void)
{
    /*启动DAC时钟*/
    RL78G13_Clock_PER0_Enable(RL78G13_CLOCK_PER0_ADCEN);
    /*关闭AD转换,并清除ADM0*/
    RL78G13_ADC_ADM0_Write_All(RL78G13_ADC_ADM0_ADCS_READ_THEN_STOP_ON,
        RL78G13_ADC_ADM0_ADMD_MODE_SELECT, RL78G13_ADC_ADM0_ADCE_COMPARE_SET_DISABLE,
        RL78G13_ADC_ADM0_FR_CONVERT_CLK_DIV_64, RL78G13_ADC_ADM0_LV_CONVERT_MODE_SET_NORMAL_19);
    /*禁止ADC中断并清除ADC中断标志*/
    RL78G13_Int_Status_Write(RL78G13_INT_SRC_AD, RL78G13_INT_STATUS_DISABLE);
    RL78G13_Int_Flag_Clear(RL78G13_INT_SRC_AD);
    /*设置ADC中断优先级*/
    RL78G13_Int_Pri_Write(RL78G13_INT_SRC_AD,RL78G13_INT_PRI_2);
    /*设置P12.0位AD,AIN19*/
    RL78G13_Port_Init(PORT_INDEX12, PORT_BIT0, RL78G13_PORT_PMn0_MODE_INPUT, RL78G13_PORT_Pn0_OUTPUT_0,
        RL78G13_PORT_PULLUP0_OFF, RL78G13_PORT_PIM0_TTL_OFF, RL78G13_PORT_POM0_NCH_OFF,
        RL78G13_PORT_PMC0_NOT_USE);
    /*设置转换,当前不转换,选择模式,比较使能,时钟分频16,1M,等待转换模式 19*/
    RL78G13_ADC_ADM0_Write_All(RL78G13_ADC_ADM0_ADCS_READ_THEN_STOP_ON, RL78G13_ADC_ADM0_ADMD_MODE_SELECT,
        RL78G13_ADC_ADM0_ADCE_COMPARE_SET_ENABLE, RL78G13_ADC_ADM0_FR_CONVERT_CLK_DIV_16,
        RL78G13_ADC_ADM0_LV_CONVERT_MODE_SET_NORMAL_19);
    /*软件触发转换,单次转换模式,外部触发随便写*/
    RL78G13_ADC_ADM1_Write_All(RL78G13_ADC_ADM1_ADTMD_TRIG_MODE_SET_SOFT, RL78G13_ADC_ADM1_ADSCM_CONVERT_MODE_SINGLE,
        RL78G13_ADC_ADM1_ADTRS_TRIG_SINGLE_SELECT_INTT_TM01);
    /*VSS VDD 中间值中断,关闭snooze模式,分辨率10位*/
    RL78G13_ADC_ADM2_Write_All(RL78G13_ADC_ADM2_ADREFP_VREFP_SELECT_VDD, RL78G13_ADC_ADM2_ADREFM_VREFM_SELECT_VSS,
        RL78G13_ADC_ADM2_ADRCK_LIMIT_MODE_MIDDLE_INT, RL78G13_ADC_ADM2_AWC_SNOOZE_MODE_DISABLE,
        RL78G13_ADC_ADM2_ADTYP_RESOLUTION_10);
    /*设置上下限*/
    RL78G13_ADC_ADUL_Write_All(255);
    RL78G13_ADC_ADLL_Write_All(0);
    /*设置转换源 AIN19*/
    RL78G13_ADC_ADS_Write_All(RL78G13_ADC_ADS_ADISS_SINGLE_SOURCE_EXTERN,
        RL78G13_ADC_ADS_ADS_SIGNAL_SOURCE_SELECT_AIN19);
    convertOver = 0;

    return DDIL_ERROR_NONE;
}




DDIL_ERROR_CODE Adc_GetValueByChannel(uint32_t channel, uint16_t* adcValue)
{
    /*清除中断标志*/
    RL78G13_Int_Flag_Clear(RL78G13_INT_SRC_AD);
    /*使能中断*/
    RL78G13_Int_Status_Write(RL78G13_INT_SRC_AD, RL78G13_INT_STATUS_ENABLE);
    convertOver = 0;
    /*开始转换*/
    RL78G13_ADC_ADM0_Write_One(RL78G13_ADC_ADM0_ADCS_READ_THEN_STOP_MASK,
        RL78G13_ADC_ADM0_ADCS_READ_THEN_STOP_OFF);
    /*等待转换完成*/
    while (convertOver == 0);
    /*读取转换值*/
    *adcValue = RL78G13_ADC_ADCR_Read_One(RL78G13_ADC_ADCR_RESULT_RESOLUTION_10_MASK);
    return DDIL_ERROR_NONE;
}

#pragma vector = INTAD_vect
__interrupt void ADC_Process(void)
{
    convertOver = 1;
}
